// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: d29e3c1aa080ed71eabf7961c4fa16c0f738838ced2374c67d5e2712cbd15d44

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry
{
    Blancmange,
    Cantor,
    Feigenbaum,
    Mandelbrot,
    FibonacciHamiltonian,
    FibonacciSnowflake,
    Julia,
    Pendulum,
    Rauzy,
    HeighwayDragon,
    Henon,
    Supergolden
}
impl ShaderEntry
{
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        match self
        {
            Self::Blancmange => blancmange::create_pipeline_layout(device),
            Self::Cantor => cantor::create_pipeline_layout(device),
            Self::Feigenbaum => feigenbaum::create_pipeline_layout(device),
            Self::Mandelbrot => mandelbrot::create_pipeline_layout(device),
            Self::FibonacciHamiltonian => fibonacci_hamiltonian::create_pipeline_layout(device),
            Self::FibonacciSnowflake => fibonacci_snowflake::create_pipeline_layout(device),
            Self::Julia => julia::create_pipeline_layout(device),
            Self::Pendulum => pendulum::create_pipeline_layout(device),
            Self::Rauzy => rauzy::create_pipeline_layout(device),
            Self::HeighwayDragon => heighway_dragon::create_pipeline_layout(device),
            Self::Henon => henon::create_pipeline_layout(device),
            Self::Supergolden => supergolden::create_pipeline_layout(device)
        }
    }

    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule
    {
        match self
        {
            Self::Blancmange => blancmange::create_shader_module_embed_source(device),
            Self::Cantor => cantor::create_shader_module_embed_source(device),
            Self::Feigenbaum => feigenbaum::create_shader_module_embed_source(device),
            Self::Mandelbrot => mandelbrot::create_shader_module_embed_source(device),
            Self::FibonacciHamiltonian => fibonacci_hamiltonian::create_shader_module_embed_source(device),
            Self::FibonacciSnowflake => fibonacci_snowflake::create_shader_module_embed_source(device),
            Self::Julia => julia::create_shader_module_embed_source(device),
            Self::Pendulum => pendulum::create_shader_module_embed_source(device),
            Self::Rauzy => rauzy::create_shader_module_embed_source(device),
            Self::HeighwayDragon => heighway_dragon::create_shader_module_embed_source(device),
            Self::Henon => henon::create_shader_module_embed_source(device),
            Self::Supergolden => supergolden::create_shader_module_embed_source(device)
        }
    }
}
mod _root
{
    pub use super::*;
    pub trait SetBindGroup
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]);
    }
    impl SetBindGroup for wgpu::RenderPass<'_>
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset])
        {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_>
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset])
        {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts
{
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of::<glam::IVec2>() == 8);
        assert!(std::mem::align_of::<glam::IVec2>() == 4);
        assert!(std::mem::size_of::<glam::IVec3>() == 12);
        assert!(std::mem::align_of::<glam::IVec3>() == 4);
        assert!(std::mem::size_of::<glam::IVec4>() == 16);
        assert!(std::mem::align_of::<glam::IVec4>() == 4);
        assert!(std::mem::size_of::<glam::UVec2>() == 8);
        assert!(std::mem::align_of::<glam::UVec2>() == 4);
        assert!(std::mem::size_of::<glam::UVec3>() == 12);
        assert!(std::mem::align_of::<glam::UVec3>() == 4);
        assert!(std::mem::size_of::<glam::UVec4>() == 16);
        assert!(std::mem::align_of::<glam::UVec4>() == 4);
        assert!(std::mem::size_of::<glam::Vec2>() == 8);
        assert!(std::mem::align_of::<glam::Vec2>() == 4);
        assert!(std::mem::size_of::<glam::Vec3>() == 12);
        assert!(std::mem::align_of::<glam::Vec3>() == 4);
        assert!(std::mem::size_of::<glam::Vec4>() == 16);
        assert!(std::mem::align_of::<glam::Vec4>() == 16);
        assert!(std::mem::size_of::<glam::Mat2>() == 16);
        assert!(std::mem::align_of::<glam::Mat2>() == 16);
        assert!(std::mem::size_of::<glam::Mat3A>() == 48);
        assert!(std::mem::align_of::<glam::Mat3A>() == 16);
        assert!(std::mem::size_of::<glam::Mat4>() == 64);
        assert!(std::mem::align_of::<glam::Mat4>() == 16);
    };
    const GLOBAL_BINDINGS_GLOBAL_UNIFORMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, time) == 0);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, window_size) == 8);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, max_iterations) == 16);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, center) == 24);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, zoom) == 32);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, rot) == 36);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, exp) == 40);
        assert!(std::mem::offset_of!(global_bindings::GlobalUniforms, shift) == 48);
        assert!(std::mem::size_of::<global_bindings::GlobalUniforms>() == 56);
    };
}
pub mod global_bindings
{
    use super::{_root, _root::*};
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VertexInput
    {
        pub vertex_id: u32
    }
    impl VertexInput
    {
        pub const fn new(vertex_id: u32) -> Self
        {
            Self { vertex_id }
        }
    }
    impl VertexInput
    {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [wgpu::VertexAttribute {
            format: wgpu::VertexFormat::Uint32,
            offset: std::mem::offset_of!(Self, vertex_id) as u64,
            shader_location: 0
        }];

        pub const fn vertex_buffer_layout(step_mode: wgpu::VertexStepMode) -> wgpu::VertexBufferLayout<'static>
        {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<Self>() as u64,
                step_mode,
                attributes: &Self::VERTEX_ATTRIBUTES
            }
        }
    }
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GlobalUniforms
    {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub time: f32,
        pub _pad_time: [u8; 0x4],
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub window_size: glam::UVec2,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub max_iterations: u32,
        pub _pad_max_iterations: [u8; 0x4],
        #[doc = "offset: 24, size: 8, type: `vec2<f32>`"]
        pub center: glam::Vec2,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub zoom: f32,
        #[doc = "offset: 36, size: 4, type: `f32`"]
        pub rot: f32,
        #[doc = "offset: 40, size: 8, type: `vec2<f32>`"]
        pub exp: glam::Vec2,
        #[doc = "offset: 48, size: 8, type: `vec2<f32>`"]
        pub shift: glam::Vec2
    }
    impl GlobalUniforms
    {
        pub const fn new(time: f32, window_size: glam::UVec2, max_iterations: u32, center: glam::Vec2, zoom: f32, rot: f32, exp: glam::Vec2, shift: glam::Vec2) -> Self
        {
            Self {
                time,
                _pad_time: [0; 0x4],
                window_size,
                max_iterations,
                _pad_max_iterations: [0; 0x4],
                center,
                zoom,
                rot,
                exp,
                shift
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GlobalUniformsInit
    {
        pub time: f32,
        pub window_size: glam::UVec2,
        pub max_iterations: u32,
        pub center: glam::Vec2,
        pub zoom: f32,
        pub rot: f32,
        pub exp: glam::Vec2,
        pub shift: glam::Vec2
    }
    impl GlobalUniformsInit
    {
        pub fn build(&self) -> GlobalUniforms
        {
            GlobalUniforms {
                time: self.time,
                _pad_time: [0; 0x4],
                window_size: self.window_size,
                max_iterations: self.max_iterations,
                _pad_max_iterations: [0; 0x4],
                center: self.center,
                zoom: self.zoom,
                rot: self.rot,
                exp: self.exp,
                shift: self.shift
            }
        }
    }
    impl From<GlobalUniformsInit> for GlobalUniforms
    {
        fn from(data: GlobalUniformsInit) -> Self
        {
            data.build()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a>
    {
        pub globals: wgpu::BufferBinding<'a>
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a>
    {
        pub globals: wgpu::BindGroupEntry<'a>
    }
    impl<'a> WgpuBindGroup0Entries<'a>
    {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self
        {
            Self {
                globals: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.globals)
                }
            }
        }

        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1]
        {
            [self.globals]
        }

        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B
        {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0
    {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("GlobalBindings::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"_root::global_bindings::globals\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<_root::global_bindings::GlobalUniforms>() as _)
                    },
                    count: None
                }
            ]
        };

        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout
        {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }

        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self
        {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GlobalBindings::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries
            });
            Self(bind_group)
        }

        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
}
pub mod bytemuck_impls
{
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for global_bindings::VertexInput {}
    unsafe impl bytemuck::Pod for global_bindings::VertexInput {}
    unsafe impl bytemuck::Zeroable for global_bindings::GlobalUniforms {}
    unsafe impl bytemuck::Pod for global_bindings::GlobalUniforms {}
}
pub mod consts
{
    use super::{_root, _root::*};
    pub const TAU: f32 = 6.2831855f32;
}
pub mod blancmange
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Blancmange::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("blancmange.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn cdivX_naga_oil_mod_XMNXW24DMMV4AX(lhs_1: vec2<f32>, rhs_1: vec2<f32>) -> vec2<f32> {
    let _e11 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(rhs_1);
    return ((mat2x2<f32>(vec2<f32>(lhs_1.x, lhs_1.y), vec2<f32>(lhs_1.y, -(lhs_1.x))) * rhs_1) / vec2(_e11));
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c_1: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c_1.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c_1.z) + ((c_1.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c_1.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

fn triangle(r: f32) -> f32 {
    return ((2f * abs((2f * (r - floor((r + 0.5f)))))) - 1f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var c: vec2<f32>;
    var z: vec2<f32>;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    c = (_e30 - _e33);
    let _e38 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    z = _e38;
    let _e40 = z;
    let _e41 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e40);
    let _e44 = c;
    let _e45 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e44);
    let r_1 = max(max(1f, _e41), _e45);
    let _e47 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e47);
    loop {
        let _e50 = i;
        let _e52 = z;
        let _e53 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e52);
        if ((_e50 < n_1) && (_e53 < (r_1 * 4f))) {
        } else {
            break;
        }
        {
            let _e59 = c;
            c = (_e59 / vec2(2f));
            let _e62 = z;
            let _e65 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e66 = cdivX_naga_oil_mod_XMNXW24DMMV4AX(_e62, _e65);
            let _e68 = c.x;
            let _e69 = triangle(_e68);
            let _e71 = c.y;
            let _e72 = triangle(_e71);
            z = (_e66 + vec2<f32>(_e69, _e72));
        }
        continuing {
            let _e76 = i;
            i = (_e76 + 1u);
        }
    }
    let _e78 = i;
    let _e80 = z;
    let _e81 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e80);
    let _e86 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e87 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e86);
    let m = (f32(_e78) - (log(log(_e81)) / log((1f / _e87))));
    let _e93 = z;
    let _e94 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e93, m);
    return _e94;
}
"#;
}
pub mod cantor
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Cantor::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("cantor.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    return atan2(x_1.y, x_1.x);
}

fn clogX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_2);
    let _e5 = argX_naga_oil_mod_XMNXW24DMMV4AX(x_2);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cexpX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> vec2<f32> {
    let _e4 = cisX_naga_oil_mod_XMNXW24DMMV4AX(x_3.y);
    return (exp(x_3.x) * _e4);
}

fn powcX_naga_oil_mod_XMNXW24DMMV4AX(x_4: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    if ((x_4.x == 0f) && (x_4.y == 0f)) {
        return vec2<f32>(0f, 0f);
    }
    let _e11 = clogX_naga_oil_mod_XMNXW24DMMV4AX(x_4);
    let _e13 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(y, _e11);
    let _e14 = cexpX_naga_oil_mod_XMNXW24DMMV4AX(_e13);
    return _e14;
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_5: f32, w: f32) -> f32 {
    return (((x_5 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_6: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_6);
    return sqrt(_e1);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var r_k: vec2<f32>;
    var i: u32 = 1u;
    var d: f32 = 0f;

    let _e10 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e15 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e10), f32(_e15)) / vec2(2f)));
    let _e24 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e29 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e30 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e29);
    let _e31 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e24)), _e30);
    let _e34 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    z = (_e31 - _e34);
    let phi = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    let lambda = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let r = (vec2<f32>((phi.y - phi.x), (phi.y - phi.x)) / vec2(2f));
    let _e53 = powcX_naga_oil_mod_XMNXW24DMMV4AX(r, lambda);
    let _e54 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(r, _e53);
    r_k = _e54;
    let c_1 = ((phi.y + phi.x) / 2f);
    let _e61 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e61);
    loop {
        let _e64 = i;
        if (_e64 < n_1) {
        } else {
            break;
        }
        {
            let _e67 = z.x;
            let _e69 = z.x;
            let _e73 = z.y;
            let _e75 = z.y;
            z = vec2<f32>((_e67 - floor(_e69)), (_e73 - floor(_e75)));
            let _e80 = z.x;
            let _e91 = d;
            d = (_e91 + pow(abs((1f - (2f * abs((_e80 - 0.5f))))), _e61));
            let _e94 = z.y;
            let _e104 = d;
            d = (_e104 + pow(abs((1f - (2f * abs((_e94 - 0.5f))))), _e61));
            let _e107 = z.x;
            let e = f32(u32((_e107 > c_1)));
            let _e112 = z.x;
            if (_e112 <= c_1) {
                let _e115 = z.x;
                let _e117 = r_k.x;
                if (_e115 > (c_1 - _e117)) {
                    break;
                } else {
                    let _e122 = r_k.x;
                    let _e124 = z.x;
                    z.x = (_e124 / (c_1 - _e122));
                }
            } else {
                let _e127 = z.x;
                let _e129 = r_k.x;
                if (_e127 < (c_1 + _e129)) {
                    break;
                } else {
                    let _e134 = z.x;
                    let _e140 = r_k.x;
                    z.x = (((_e134 - 1f) / ((1f - c_1) - _e140)) + 1f);
                }
            }
            let _e146 = z.y;
            if (_e146 <= c_1) {
                let _e149 = z.y;
                let _e151 = r_k.y;
                if (_e149 > (c_1 - _e151)) {
                    break;
                } else {
                    let _e156 = r_k.y;
                    let _e158 = z.y;
                    z.y = (_e158 / (c_1 - _e156));
                }
            } else {
                let _e161 = z.y;
                let _e163 = r_k.y;
                if (_e161 < (c_1 + _e163)) {
                    break;
                } else {
                    let _e168 = z.y;
                    let _e174 = r_k.y;
                    z.y = (((_e168 - 1f) / ((1f - c_1) - _e174)) + 1f);
                }
            }
            let _e179 = r_k;
            let _e180 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e179, _e53);
            r_k = _e180;
        }
        continuing {
            let _e182 = i;
            i = (_e182 + 1u);
        }
    }
    let _e184 = i;
    let _e186 = d;
    let m = (f32(_e184) - sqrt(_e186));
    let _e189 = z;
    let _e190 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e189, m);
    return _e190;
}
"#;
}
pub mod feigenbaum
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Feigenbaum::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("feigenbaum.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

fn triangle(z_2: f32) -> f32 {
    return (z_2 - round(z_2));
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    let c_1 = (_e30 - _e33);
    let _e37 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    z = _e37;
    let _e39 = z;
    let _e40 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e39);
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(c_1);
    let r = max(max(1f, _e40), _e43);
    let _e45 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e45);
    loop {
        let _e48 = i;
        let _e50 = z;
        let _e51 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e50);
        if ((_e48 < n_1) && (_e51 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e56 = z;
            let _e57 = z;
            let _e62 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e56, (vec2<f32>(1f, 0f) - _e57));
            let _e63 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(c_1, _e62);
            let _e66 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
            z = (_e63 + _e66);
        }
        continuing {
            let _e69 = i;
            i = (_e69 + 1u);
        }
    }
    let _e71 = i;
    let _e73 = z;
    let _e74 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e73);
    let _e79 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e80 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e79);
    let m = (f32(_e71) - (log(log(_e74)) / log(_e80)));
    let _e84 = z;
    let _e85 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e84, m);
    return _e85;
}
"#;
}
pub mod mandelbrot
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Mandelbrot::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("mandelbrot.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> f32 {
    return atan2(x_2.y, x_2.x);
}

fn clogX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    let _e5 = argX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cexpX_naga_oil_mod_XMNXW24DMMV4AX(x_4: vec2<f32>) -> vec2<f32> {
    let _e4 = cisX_naga_oil_mod_XMNXW24DMMV4AX(x_4.y);
    return (exp(x_4.x) * _e4);
}

fn powcX_naga_oil_mod_XMNXW24DMMV4AX(x_5: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    if ((x_5.x == 0f) && (x_5.y == 0f)) {
        return vec2<f32>(0f, 0f);
    }
    let _e11 = clogX_naga_oil_mod_XMNXW24DMMV4AX(x_5);
    let _e13 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(y, _e11);
    let _e14 = cexpX_naga_oil_mod_XMNXW24DMMV4AX(_e13);
    return _e14;
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_6: f32, w: f32) -> f32 {
    return (((x_6 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    let c_1 = (_e30 - _e33);
    let _e37 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    z = _e37;
    let _e39 = z;
    let _e40 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e39);
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(c_1);
    let r = max(max(1f, _e40), _e43);
    let _e45 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e45);
    loop {
        let _e48 = i;
        let _e50 = z;
        let _e51 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e50);
        if ((_e48 < n_1) && (_e51 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e56 = z;
            let _e59 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e60 = powcX_naga_oil_mod_XMNXW24DMMV4AX(_e56, _e59);
            z = (_e60 + c_1);
        }
        continuing {
            let _e63 = i;
            i = (_e63 + 1u);
        }
    }
    let _e65 = i;
    let _e67 = z;
    let _e68 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e67);
    let _e73 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e74 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e73);
    let m = (f32(_e65) - (log(log(_e68)) / log(_e74)));
    let _e78 = z;
    let _e79 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e78, m);
    return _e79;
}
"#;
}
pub mod fibonacci_hamiltonian
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("FibonacciHamiltonian::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("fibonacci_hamiltonian.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: u32 = 0u;
    var z_prev: vec2<f32>;
    var z_prev_prev: vec2<f32>;
    var z_prev_1: vec2<f32>;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    let e = (_e30 - _e33);
    let _e37 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    z = _e37;
    let lambda = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e42 = z;
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e42);
    let r = max(1f, _e43);
    let _e46 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e46);
    let _e48 = z;
    let _e49 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e48);
    if (_e49 <= (r * 4f)) {
        let _e53 = z;
        z_prev = _e53;
        z = e;
        let _e57 = i;
        i = (_e57 + 1u);
        let _e59 = z;
        let _e60 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e59);
        if (_e60 <= (r * 4f)) {
            let _e64 = z_prev;
            z_prev_prev = _e64;
            let _e66 = z;
            z_prev_1 = _e66;
            z = (e - lambda);
            let _e70 = i;
            i = (_e70 + 1u);
            loop {
                let _e72 = i;
                let _e74 = z;
                let _e75 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e74);
                if ((_e72 < n_1) && (_e75 <= (r * 4f))) {
                } else {
                    break;
                }
                {
                    let _e80 = z;
                    let _e81 = z_prev_1;
                    let _e82 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e80, _e81);
                    let _e83 = z_prev_prev;
                    let z_next = (_e82 - _e83);
                    let _e85 = z_prev_1;
                    z_prev_prev = _e85;
                    let _e86 = z;
                    z_prev_1 = _e86;
                    z = z_next;
                }
                continuing {
                    let _e88 = i;
                    i = (_e88 + 1u);
                }
            }
        }
    }
    let _e90 = i;
    let _e92 = z;
    let _e93 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e92);
    let _e98 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e99 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e98);
    let m = (f32(_e90) - (log(log(_e93)) / log(_e99)));
    let _e103 = z;
    let _e104 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e103, m);
    return _e104;
}
"#;
}
pub mod fibonacci_snowflake
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("FibonacciSnowflake::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("fibonacci_snowflake.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn conjX_naga_oil_mod_XMNXW24DMMV4AX(z_1: vec2<f32>) -> vec2<f32> {
    return vec2<f32>(z_1.x, -(z_1.y));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c_1: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c_1.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c_1.z) + ((c_1.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c_1.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_2: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_2);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_2);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n_1 = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n_1))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n_1))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var c: vec2<f32>;
    var n: f32;
    var i: u32 = 0u;
    var m_prev: u32 = 1u;
    var m: u32 = 1u;
    var z_prev: vec2<f32>;
    var v: vec2<f32>;

    let _e10 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e15 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e10), f32(_e15)) / vec2(2f)));
    let _e24 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e29 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e30 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e29);
    let _e31 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e24)), _e30);
    let _e34 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    z = (_e31 - _e34);
    let _e39 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    c = _e39;
    let _e41 = z;
    let _e42 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e41);
    let _e45 = c;
    let _e46 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e45);
    let r = max(max(1f, _e42), _e46);
    let _e48 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    n = _e48;
    let _e50 = z;
    let _e51 = c;
    z_prev = (_e50 + _e51);
    loop {
        let _e55 = i;
        let _e56 = n;
        let _e59 = z;
        let _e60 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e59);
        if ((_e55 < u32(_e56)) && (_e60 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e67 = m_prev;
            let _e68 = m;
            let m_next = (_e67 + _e68);
            let _e70 = m;
            m_prev = _e70;
            m = m_next;
            let _e71 = z;
            let _e72 = z_prev;
            let _e74 = c;
            v = ((_e71 - _e72) + _e74);
            let _e77 = m_prev;
            let _e82 = m;
            if (((_e77 % 2u) == 0u) == ((_e82 % 2u) == 0u)) {
                let _e88 = i;
                if ((_e88 % 2u) == 0u) {
                    let _e93 = v;
                    let _e96 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
                    let _e97 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e93, _e96);
                    v = _e97;
                } else {
                    let _e98 = i;
                    if ((_e98 % 2u) == 1u) {
                        let _e103 = v;
                        let _e106 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
                        let _e107 = conjX_naga_oil_mod_XMNXW24DMMV4AX(_e106);
                        let _e108 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e103, _e107);
                        v = _e108;
                    }
                }
            }
            let _e109 = z;
            z_prev = _e109;
            let _e110 = v;
            let _e111 = z;
            z = (_e111 + _e110);
        }
        continuing {
            let _e114 = i;
            i = (_e114 + 1u);
        }
    }
    let _e116 = i;
    let _e118 = z;
    let _e119 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e118);
    let _e124 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e125 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e124);
    let mag = (f32(_e116) - (log(log(_e119)) / log(_e125)));
    let _e129 = z;
    let _e130 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e129, mag);
    return _e130;
}
"#;
}
pub mod julia
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Julia::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("julia.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> f32 {
    return atan2(x_2.y, x_2.x);
}

fn clogX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    let _e5 = argX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cexpX_naga_oil_mod_XMNXW24DMMV4AX(x_4: vec2<f32>) -> vec2<f32> {
    let _e4 = cisX_naga_oil_mod_XMNXW24DMMV4AX(x_4.y);
    return (exp(x_4.x) * _e4);
}

fn powcX_naga_oil_mod_XMNXW24DMMV4AX(x_5: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    if ((x_5.x == 0f) && (x_5.y == 0f)) {
        return vec2<f32>(0f, 0f);
    }
    let _e11 = clogX_naga_oil_mod_XMNXW24DMMV4AX(x_5);
    let _e13 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(y, _e11);
    let _e14 = cexpX_naga_oil_mod_XMNXW24DMMV4AX(_e13);
    return _e14;
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_6: f32, w: f32) -> f32 {
    return (((x_6 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c_1: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c_1.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c_1.z) + ((c_1.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c_1.z) - 1f)))));
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n_1 = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n_1))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n_1))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var c: vec2<f32>;
    var n: f32;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    z = (_e30 - _e33);
    let _e38 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    c = _e38;
    let _e40 = z;
    let _e41 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e40);
    let _e44 = c;
    let _e45 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e44);
    let r = max(max(1f, _e41), _e45);
    let _e47 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    n = _e47;
    loop {
        let _e50 = i;
        let _e51 = n;
        let _e54 = z;
        let _e55 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e54);
        if ((_e50 < u32(_e51)) && (_e55 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e60 = z;
            let _e63 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e64 = powcX_naga_oil_mod_XMNXW24DMMV4AX(_e60, _e63);
            let _e65 = c;
            z = (_e64 + _e65);
        }
        continuing {
            let _e68 = i;
            i = (_e68 + 1u);
        }
    }
    let _e70 = i;
    let _e72 = z;
    let _e73 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e72);
    let _e78 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e79 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e78);
    let m = (f32(_e70) - (log(log(_e73)) / log(_e79)));
    let _e83 = z;
    let _e84 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e83, m);
    return _e84;
}
"#;
}
pub mod pendulum
{
    use super::{_root, _root::*};
    pub const G: f32 = 9.8f32;
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Pendulum::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("pendulum.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

struct PendulumState {
    theta1_: f32,
    theta2_: f32,
    p1_: f32,
    p2_: f32,
}

struct Derivatives {
    dtheta1_: f32,
    dtheta2_: f32,
    dp1_: f32,
    dp2_: f32,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;
const G: f32 = 9.8f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x: f32, w: f32) -> f32 {
    return (((x % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    return dot(x_1, x_1);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_2);
    return sqrt(_e1);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap4X_naga_oil_mod_XMNXWY33SNVQXAX(z: vec2<f32>) -> vec4<f32> {
    let _e7 = wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(((z.x / TAUX_naga_oil_mod_XMNXW443UOMX) + 0.25f), 1f);
    let light = (0.25f + (_e7 * 0.5f));
    let _e16 = wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX((z.y / TAUX_naga_oil_mod_XMNXW443UOMX), 1f);
    let _e19 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(_e16, 0.5f, light));
    return vec4<f32>(_e19, 0.8f);
}

fn compute_derivatives(state_1: PendulumState) -> Derivatives {
    var der: Derivatives = Derivatives();

    let theta1_ = state_1.theta1_;
    let theta2_ = state_1.theta2_;
    let p1_ = state_1.p1_;
    let p2_ = state_1.p2_;
    let delta = (theta1_ - theta2_);
    let cos_delta = cos(delta);
    let sin_delta = sin(delta);
    let denominator = (16f - ((9f * cos_delta) * cos_delta));
    let coeff = (6f / denominator);
    let dtheta1_ = (coeff * ((2f * p1_) - ((3f * cos_delta) * p2_)));
    let dtheta2_ = (coeff * ((8f * p2_) - ((3f * cos_delta) * p1_)));
    let endbit = ((dtheta1_ * dtheta2_) * sin_delta);
    let dp1_ = (-0.5f * ((29.400002f * sin(theta1_)) + endbit));
    let dp2_ = (-0.5f * ((G * sin(theta2_)) - endbit));
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift.x;
    der.dtheta1_ = (dtheta1_ + _e48);
    let _e54 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift.y;
    der.dtheta2_ = (dtheta2_ + _e54);
    der.dp1_ = dp1_;
    der.dp2_ = dp2_;
    let _e58 = der;
    return _e58;
}

fn rk4_step(state_2: PendulumState, dt: f32) -> PendulumState {
    var newState: PendulumState = PendulumState();

    let _e2 = compute_derivatives(state_2);
    let s2_ = PendulumState((state_2.theta1_ + ((0.5f * dt) * _e2.dtheta1_)), (state_2.theta2_ + ((0.5f * dt) * _e2.dtheta2_)), (state_2.p1_ + ((0.5f * dt) * _e2.dp1_)), (state_2.p2_ + ((0.5f * dt) * _e2.dp2_)));
    let _e29 = compute_derivatives(s2_);
    let s3_ = PendulumState((state_2.theta1_ + ((0.5f * dt) * _e29.dtheta1_)), (state_2.theta2_ + ((0.5f * dt) * _e29.dtheta2_)), (state_2.p1_ + ((0.5f * dt) * _e29.dp1_)), (state_2.p2_ + ((0.5f * dt) * _e29.dp2_)));
    let _e55 = compute_derivatives(s3_);
    let s4_ = PendulumState((state_2.theta1_ + (dt * _e55.dtheta1_)), (state_2.theta2_ + (dt * _e55.dtheta2_)), (state_2.p1_ + (dt * _e55.dp1_)), (state_2.p2_ + (dt * _e55.dp2_)));
    let _e73 = compute_derivatives(s4_);
    let dt6_ = (dt / 6f);
    newState.theta1_ = ((state_2.theta1_ + (dt6_ * (((_e2.dtheta1_ + (2f * _e29.dtheta1_)) + (2f * _e55.dtheta1_)) + _e73.dtheta1_))) % TAUX_naga_oil_mod_XMNXW443UOMX);
    newState.theta2_ = ((state_2.theta2_ + (dt6_ * (((_e2.dtheta2_ + (2f * _e29.dtheta2_)) + (2f * _e55.dtheta2_)) + _e73.dtheta2_))) % TAUX_naga_oil_mod_XMNXW443UOMX);
    newState.p1_ = (state_2.p1_ + (dt6_ * (((_e2.dp1_ + (2f * _e29.dp1_)) + (2f * _e55.dp1_)) + _e73.dp1_)));
    newState.p2_ = (state_2.p2_ + (dt6_ * (((_e2.dp2_ + (2f * _e29.dp2_)) + (2f * _e55.dp2_)) + _e73.dp2_)));
    let _e141 = newState;
    return _e141;
}

fn pendulum_z(state_3: PendulumState) -> vec2<f32> {
    return vec2<f32>((sin(state_3.theta1_) + sin(state_3.theta2_)), (cos(state_3.theta1_) + cos(state_3.theta2_)));
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var state: PendulumState;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    let arg = (_e30 - _e33);
    let _e40 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp.x;
    let _e44 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp.y;
    state = PendulumState(arg.x, arg.y, _e40, _e44);
    let _e47 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let _e50 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.time;
    let dt_1 = (sqrt(_e50) / _e47);
    loop {
        let _e54 = i;
        if (_e54 < u32(_e47)) {
        } else {
            break;
        }
        {
            let _e57 = state;
            let _e58 = rk4_step(_e57, dt_1);
            state = _e58;
        }
        continuing {
            let _e60 = i;
            i = (_e60 + 1u);
        }
    }
    let _e62 = state;
    let _e65 = rk4_step(_e62, (dt_1 * fract(_e47)));
    state = _e65;
    let _e66 = state;
    let _e67 = pendulum_z(_e66);
    let _e68 = colormap4X_naga_oil_mod_XMNXWY33SNVQXAX(_e67);
    return _e68;
}
"#;
}
pub mod rauzy
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Rauzy::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("rauzy.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: u32 = 0u;
    var z_prev: vec2<f32>;
    var z_prev_prev: vec2<f32>;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    let a = (_e30 - _e33);
    let _e37 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    z = _e37;
    let b = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e42 = z;
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e42);
    let r = max(1f, _e43);
    let _e46 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e46);
    let _e48 = z;
    let _e49 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e48);
    if (_e49 <= (r * 4f)) {
        let _e53 = z;
        z_prev = _e53;
        z = a;
        let _e57 = i;
        i = (_e57 + 1u);
        let _e59 = z;
        let _e60 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e59);
        if (_e60 <= (r * 4f)) {
            let _e64 = z;
            let _e65 = z_prev;
            let _e66 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e64, _e65);
            let z_next = (_e66 + b);
            let _e68 = z_prev;
            z_prev_prev = _e68;
            let _e70 = z;
            z_prev = _e70;
            z = z_next;
            let _e72 = i;
            i = (_e72 + 1u);
            loop {
                let _e74 = i;
                let _e76 = z;
                let _e77 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e76);
                if ((_e74 < n_1) && (_e77 <= (r * 4f))) {
                } else {
                    break;
                }
                {
                    let _e82 = z;
                    let _e83 = z_prev_prev;
                    let _e84 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e82, _e83);
                    let _e85 = z_prev;
                    let z_next_1 = (_e84 - _e85);
                    let _e87 = z_prev;
                    z_prev_prev = _e87;
                    let _e88 = z;
                    z_prev = _e88;
                    z = z_next_1;
                }
                continuing {
                    let _e90 = i;
                    i = (_e90 + 1u);
                }
            }
        }
    }
    let _e92 = i;
    let _e94 = z;
    let _e95 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e94);
    let _e100 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e101 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e100);
    let m = (f32(_e92) - (log(log(_e95)) / log(_e101)));
    let _e105 = z;
    let _e106 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e105, m);
    return _e106;
}
"#;
}
pub mod heighway_dragon
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("HeighwayDragon::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("heighway_dragon.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn conjX_naga_oil_mod_XMNXW24DMMV4AX(z_1: vec2<f32>) -> vec2<f32> {
    return vec2<f32>(z_1.x, -(z_1.y));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_2: f32, w: f32) -> f32 {
    return (((x_2 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c_1: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c_1.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c_1.z) + ((c_1.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c_1.z) - 1f)))));
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> f32 {
    return atan2(x_3.y, x_3.x);
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_2: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_2);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_2);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n_1 = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n_1))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n_1))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var c: vec2<f32>;
    var z: vec2<f32>;
    var n: f32;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    c = (_e30 - _e33);
    let _e38 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    z = _e38;
    let _e40 = z;
    let _e41 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e40);
    let _e44 = c;
    let _e45 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e44);
    let r = max(max(1f, _e41), _e45);
    let _e47 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    n = _e47;
    loop {
        let _e50 = i;
        let _e51 = n;
        let _e54 = z;
        let _e55 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e54);
        if ((_e50 < u32(_e51)) && (_e55 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e60 = c;
            let _e61 = z;
            let _e64 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e65 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e61, _e64);
            let _e68 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e69 = conjX_naga_oil_mod_XMNXW24DMMV4AX(_e68);
            let _e70 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(_e65, _e69);
            let _e72 = z;
            z = (_e72 - (_e60 - _e70));
        }
        continuing {
            let _e75 = i;
            i = (_e75 + 1u);
        }
    }
    let _e77 = i;
    let _e79 = z;
    let _e80 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e79);
    let _e85 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e86 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e85);
    let m = (f32(_e77) - (log(log(_e80)) / log(_e86)));
    let _e90 = z;
    let _e91 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e90, m);
    return _e91;
}
"#;
}
pub mod henon
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Henon::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("henon.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> f32 {
    return atan2(x_2.y, x_2.x);
}

fn clogX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    let _e5 = argX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cexpX_naga_oil_mod_XMNXW24DMMV4AX(x_4: vec2<f32>) -> vec2<f32> {
    let _e4 = cisX_naga_oil_mod_XMNXW24DMMV4AX(x_4.y);
    return (exp(x_4.x) * _e4);
}

fn powcX_naga_oil_mod_XMNXW24DMMV4AX(x_5: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    if ((x_5.x == 0f) && (x_5.y == 0f)) {
        return vec2<f32>(0f, 0f);
    }
    let _e11 = clogX_naga_oil_mod_XMNXW24DMMV4AX(x_5);
    let _e13 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(y, _e11);
    let _e14 = cexpX_naga_oil_mod_XMNXW24DMMV4AX(_e13);
    return _e14;
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_6: f32, w: f32) -> f32 {
    return (((x_6 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n_1 = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n_1))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n_1))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var n: f32;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    z = (_e30 - _e33);
    let c_1 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    let _e39 = z;
    let _e40 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e39);
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(c_1);
    let r = max(max(1f, _e40), _e43);
    let _e45 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    n = _e45;
    loop {
        let _e48 = i;
        let _e49 = n;
        let _e52 = z;
        let _e53 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e52);
        if ((_e48 < u32(_e49)) && (_e53 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e59 = z.y;
            let _e63 = z.x;
            let _e67 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift.y;
            let _e71 = z.x;
            let _e76 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e77 = powcX_naga_oil_mod_XMNXW24DMMV4AX(vec2<f32>(_e71, 0f), _e76);
            let _e81 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift.x;
            z = (vec2<f32>((1f + _e59), (_e63 * _e67)) - (_e77 * _e81));
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e87 = i;
    let _e89 = z;
    let _e90 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e89);
    let _e95 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e96 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e95);
    let m = (f32(_e87) - (log(log(_e90)) / log(_e96)));
    let _e100 = z;
    let _e101 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e100, m);
    return _e101;
}
"#;
}
pub mod supergolden
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Supergolden::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("supergolden.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @builtin(vertex_index) vertex_index: u32,
    @location(0) @interpolate(flat) vertex_id: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    time: f32,
    window_size: vec2<u32>,
    max_iterations: u32,
    center: vec2<f32>,
    zoom: f32,
    rot: f32,
    exp: vec2<f32>,
    shift: vec2<f32>,
}

const TAUX_naga_oil_mod_XMNXW443UOMX: f32 = 6.2831855f;

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX() -> f32 {
    let _e2 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.max_iterations;
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    return (f32(_e2) * max(1f, log(_e6)));
}

fn cisX_naga_oil_mod_XMNXW24DMMV4AX(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cmulX_naga_oil_mod_XMNXW24DMMV4AX(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return (mat2x2<f32>(vec2<f32>(lhs.x, lhs.y), vec2<f32>(-(lhs.y), lhs.x)) * rhs);
}

fn norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x: vec2<f32>) -> f32 {
    return dot(x, x);
}

fn normX_naga_oil_mod_XMNXW24DMMV4AX(x_1: vec2<f32>) -> f32 {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_1);
    return sqrt(_e1);
}

fn argX_naga_oil_mod_XMNXW24DMMV4AX(x_2: vec2<f32>) -> f32 {
    return atan2(x_2.y, x_2.x);
}

fn clogX_naga_oil_mod_XMNXW24DMMV4AX(x_3: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    let _e5 = argX_naga_oil_mod_XMNXW24DMMV4AX(x_3);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cexpX_naga_oil_mod_XMNXW24DMMV4AX(x_4: vec2<f32>) -> vec2<f32> {
    let _e4 = cisX_naga_oil_mod_XMNXW24DMMV4AX(x_4.y);
    return (exp(x_4.x) * _e4);
}

fn powcX_naga_oil_mod_XMNXW24DMMV4AX(x_5: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    if ((x_5.x == 0f) && (x_5.y == 0f)) {
        return vec2<f32>(0f, 0f);
    }
    let _e11 = clogX_naga_oil_mod_XMNXW24DMMV4AX(x_5);
    let _e13 = cmulX_naga_oil_mod_XMNXW24DMMV4AX(y, _e11);
    let _e14 = cexpX_naga_oil_mod_XMNXW24DMMV4AX(_e13);
    return _e14;
}

fn wrapX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX(x_6: f32, w: f32) -> f32 {
    return (((x_6 % w) + w) % w);
}

fn hsl2rgbX_naga_oil_mod_XMNXWY33SX(c: vec3<f32>) -> vec3<f32> {
    let rgb = clamp((abs((((vec3((c.x * 6f)) + vec3<f32>(0f, 4f, 2f)) % vec3(6f)) - vec3(3f))) - vec3(1f)), vec3<f32>(0f, 0f, 0f), vec3<f32>(1f, 1f, 1f));
    return (vec3(c.z) + ((c.y * (rgb - vec3(0.5f))) * (1f - abs(((2f * c.z) - 1f)))));
}

fn colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(z_1: vec2<f32>, i_1: f32) -> vec4<f32> {
    let _e0 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let t = clamp(((i_1 / _e0) % 1f), 0f, 1f);
    let _e9 = normX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let z_norm = (1f - exp(-(f32(_e9))));
    let _e15 = argX_naga_oil_mod_XMNXW24DMMV4AX(z_1);
    let hue = ((f32(_e15) / 6.2831855f) + 0.5f);
    let _e24 = hsl2rgbX_naga_oil_mod_XMNXWY33SX(vec3<f32>(hue, (z_norm / 2f), t));
    return vec4<f32>(_e24, 0.8f);
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let corner = (in.vertex_index % 3u);
    let n = (((in.vertex_index / 3u) % 2u) == 1u);
    let _e21 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e27 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e42 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let _e48 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos = vec2<f32>((f32((u32(((corner == 1u) || ((corner == 0u) && n))) * _e21)) - (f32(_e27) / 2f)), (f32((u32(((corner == 2u) || ((corner == 0u) && n))) * _e42)) - (f32(_e48) / 2f)));
    return vec4<f32>(pos, 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: u32 = 0u;

    let _e9 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.x;
    let _e14 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.window_size.y;
    let pos_1 = ((position.xy / vec2(position.w)) - (vec2<f32>(f32(_e9), f32(_e14)) / vec2(2f)));
    let _e23 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.zoom;
    let _e28 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.rot;
    let _e29 = cisX_naga_oil_mod_XMNXW24DMMV4AX(_e28);
    let _e30 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((pos_1 / vec2(_e23)), _e29);
    let _e33 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.center;
    z = (_e30 - _e33);
    let c_1 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.shift;
    let _e39 = z;
    let _e40 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e39);
    let _e43 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(c_1);
    let r = max(max(1f, _e40), _e43);
    let _e45 = max_iterationsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX();
    let n_1 = u32(_e45);
    loop {
        let _e48 = i;
        let _e50 = z;
        let _e51 = norm_sqrX_naga_oil_mod_XMNXW24DMMV4AX(_e50);
        if ((_e48 < n_1) && (_e51 < (r * 4f))) {
        } else {
            break;
        }
        {
            let _e56 = z;
            let _e58 = z;
            let _e61 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e62 = powcX_naga_oil_mod_XMNXW24DMMV4AX(_e58, _e61);
            let _e63 = cmulX_naga_oil_mod_XMNXW24DMMV4AX((_e56 + c_1), _e62);
            z = (_e63 + c_1);
        }
        continuing {
            let _e66 = i;
            i = (_e66 + 1u);
        }
    }
    let _e68 = i;
    let _e70 = z;
    let _e71 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e70);
    let _e76 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
    let _e77 = normX_naga_oil_mod_XMNXW24DMMV4AX(_e76);
    let m = (f32(_e68) - (log(log(_e71)) / log(_e77)));
    let _e81 = z;
    let _e82 = colormap3X_naga_oil_mod_XMNXWY33SNVQXAX(_e81, m);
    return _e82;
}
"#;
}
