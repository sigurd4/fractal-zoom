// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: b273f620561382c54b9608ccac0c38e4d21dd3b56ef8d8b28464be07c861cd83

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry
{
    Mandelbrot
}
impl ShaderEntry
{
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        match self
        {
            Self::Mandelbrot => mandelbrot::create_pipeline_layout(device)
        }
    }

    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule
    {
        match self
        {
            Self::Mandelbrot => mandelbrot::create_shader_module_embed_source(device)
        }
    }
}
mod _root
{
    pub use super::*;
    pub trait SetBindGroup
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset]);
    }
    impl SetBindGroup for wgpu::RenderPass<'_>
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset])
        {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_>
    {
        fn set_bind_group(&mut self, index: u32, bind_group: &wgpu::BindGroup, offsets: &[wgpu::DynamicOffset])
        {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod global_bindings
{
    use super::{_root, _root::*};
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, encase :: ShaderType)]
    pub struct VertexInput
    {
        pub position: nalgebra::SVector<f32, 2>
    }
    impl VertexInput
    {
        pub const fn new(position: nalgebra::SVector<f32, 2>) -> Self
        {
            Self { position }
        }
    }
    impl VertexInput
    {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 1] = [wgpu::VertexAttribute {
            format: wgpu::VertexFormat::Float32x2,
            offset: std::mem::offset_of!(Self, position) as u64,
            shader_location: 0
        }];

        pub const fn vertex_buffer_layout(step_mode: wgpu::VertexStepMode) -> wgpu::VertexBufferLayout<'static>
        {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<Self>() as u64,
                step_mode,
                attributes: &Self::VERTEX_ATTRIBUTES
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, encase :: ShaderType)]
    pub struct GlobalUniforms
    {
        pub view: nalgebra::SMatrix<f32, 3, 2>,
        pub exp: nalgebra::SVector<f32, 2>
    }
    impl GlobalUniforms
    {
        pub const fn new(view: nalgebra::SMatrix<f32, 3, 2>, exp: nalgebra::SVector<f32, 2>) -> Self
        {
            Self { view, exp }
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a>
    {
        pub globals: wgpu::BufferBinding<'a>
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a>
    {
        pub globals: wgpu::BindGroupEntry<'a>
    }
    impl<'a> WgpuBindGroup0Entries<'a>
    {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self
        {
            Self {
                globals: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.globals)
                }
            }
        }

        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1]
        {
            [self.globals]
        }

        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B
        {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0
    {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("GlobalBindings::BindGroup0::LayoutDescriptor"),
            entries: &[
                #[doc = " @binding(0): \"_root::global_bindings::globals\""]
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<_root::global_bindings::GlobalUniforms>() as _)
                    },
                    count: None
                }
            ]
        };

        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout
        {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }

        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self
        {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GlobalBindings::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries
            });
            Self(bind_group)
        }

        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
}
pub mod layout_asserts
{
    use super::{_root, _root::*};
}
pub mod bytemuck_impls
{
    use super::{_root, _root::*};
}
pub mod mandelbrot
{
    use super::{_root, _root::*};
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn vertex_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a VertexEntry<N>) -> wgpu::VertexState<'a>
    {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1>
    {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [global_bindings::VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default()
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize>
    {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>
    }
    pub fn fragment_state<'a, const N: usize>(module: &'a wgpu::ShaderModule, entry: &'a FragmentEntry<N>) -> wgpu::FragmentState<'a>
    {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            }
        }
    }
    pub fn fs_main_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1>
    {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default()
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a>
    {
        pub bind_group0: &'a global_bindings::WgpuBindGroup0
    }
    impl<'a> WgpuBindGroups<'a>
    {
        pub fn set(&self, pass: &mut impl SetBindGroup)
        {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout
    {
        pub fn bind_group_layout_entries(entries: [wgpu::BindGroupLayout; 1]) -> [wgpu::BindGroupLayout; 1]
        {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout
    {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Mandelbrot::PipelineLayout"),
            bind_group_layouts: &[&global_bindings::WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[]
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule
    {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("mandelbrot.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source)
        })
    }
    pub const SHADER_STRING: &str = r#"
struct VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    @location(0) position: vec2<f32>,
    @builtin(vertex_index) vertex_index: u32,
}

struct GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX {
    view: mat2x3<f32>,
    exp: vec2<f32>,
}

@group(0) @binding(0) 
var<uniform> globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX: GlobalUniformsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX;

fn norm_sqr(x: vec2<f32>) -> f32 {
    return ((x.x * x.x) + (x.y * x.y));
}

fn arg(x_1: vec2<f32>) -> f32 {
    return atan2(x_1.y, x_1.x);
}

fn clog(x_2: vec2<f32>) -> vec2<f32> {
    let _e1 = norm_sqr(x_2);
    let _e5 = arg(x_2);
    return vec2<f32>((log(_e1) / 2f), _e5);
}

fn cis(rot: f32) -> vec2<f32> {
    return vec2<f32>(cos(rot), sin(rot));
}

fn cexp(x_3: vec2<f32>) -> vec2<f32> {
    let _e4 = cis(x_3.y);
    return (exp(x_3.x) * _e4);
}

fn powc(x_4: vec2<f32>, y: vec2<f32>) -> vec2<f32> {
    let _e1 = clog(x_4);
    let _e4 = cexp((y * _e1));
    return _e4;
}

fn norm(x_5: vec2<f32>) -> f32 {
    let _e1 = norm_sqr(x_5);
    return sqrt(_e1);
}

fn cmul(lhs: vec2<f32>, rhs: vec2<f32>) -> vec2<f32> {
    return vec2<f32>(((lhs.x * rhs.x) - (lhs.y * rhs.y)), ((lhs.x * lhs.y) + (lhs.y * rhs.x)));
}

@vertex 
fn vs_main(in: VertexInputX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX) -> @builtin(position) vec4<f32> {
    let _e6 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.view;
    return vec4<f32>((vec3<f32>(in.position, 1f) * _e6), 0f, 1f);
}

@fragment 
fn fs_main(@builtin(position) position: vec4<f32>) -> @location(0) vec4<f32> {
    var z: vec2<f32>;
    var i: i32 = 0i;

    let c = (position.xy / vec2(position.w));
    z = c;
    loop {
        let _e8 = i;
        let _e11 = z;
        let _e12 = norm_sqr(_e11);
        if ((_e8 < 1024i) && (_e12 < 4f)) {
        } else {
            break;
        }
        {
            let _e16 = z;
            let _e19 = globalsX_naga_oil_mod_XM5WG6YTBNRPWE2LOMRUW4Z3TX.exp;
            let _e20 = powc(_e16, _e19);
            z = (_e20 + c);
        }
        continuing {
            let _e23 = i;
            i = (_e23 + 1i);
        }
    }
    let _e25 = z;
    let _e26 = norm(_e25);
    let _e28 = z.x;
    let _e31 = z.y;
    let color = vec2<f32>((_e26 + _e28), (_e26 + _e31));
    return vec4<f32>(color.x, ((_e26 * 2f) - ((color.x + color.y) / 2f)), color.y, (_e26 * 2f));
}
"#;
}
